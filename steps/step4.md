# Virtual address space isolation
Сейчас в HeLL OS у всех тасков единое адресное пространство, поэтому «процессов» не существует. Изоляция адресных пространств процессов — основная задача ОС, поэтому вам нужно будет её поддержать.

**Цель:** ваша задача заключается в том, чтобы у каждого процесса было своё адресное пространство, в котором он может выделять себе адреса (меньшие KERNEL_HIGH). Ядерные адреса (начиная с KERNEL_HIGH) должны присутсововать во всех адресных пространствах, чтобы во время сисколла ядро имело доступ ко всем своим внутренним структурам. Также необходимо поддержать аналог `mmap`. Важно сделать так, чтобы сисколл умел создавать маппинги заданного размера (учтите, что они могут быть не выровненны по размеру страницы), а также вешать на них read-only флаг.

# Syscall arguments validation
Во реализации многих системных вызовах вам потребуется оперировать строками произвольной длины: как копировать из user space, так и записывать в user space. Чтобы не генерировать pagefault'ы внутри сисиколлов, нужно перед каждым копированием проверять, ссылается ли указатель на валидную область памяти. Самый простой вариант реализации такой проверки — написать функцию, которая проходит по текущим таблицам и проверяет, что каждая PTE валидна и доступна на чтение (или запись).

**Цель:** нужно реализовать функции `int check_ptr_<from|to>_userspace(struct task* task, void* addr, size_t sz)`, которая по заданному процессу, указателю и размеру проверяет, возможно ли прочитать/записать в указанную память.

# `fork`, `wait` и `exit`
**Цель:** реализовать POSIX-совместимые системные вызовы `fork`, `wait` и `exit`.

# Для души: lazy FPU context switching
Функция `__switch_to`, переключающая контекст внутри ядра, не учитывает, что процессы могут изменять состояние FPU. Однако, большинство процессов не использует вычисления с плавающей точкой и сохранять расширенный контекст — очень дорого. Поэтому ОС сохраняют `st(i)`/`xmm`/`zmm`/etc регистры только если процесс их хотя бы раз менял — это называется lazy FPU context switch. Чтобы отследить использование процессом FPU, перед запуском процесса выставляется флаг `CR0.TS`, который триггерит `#NM` при выполнении первой FPU-инструкции.

**Цель:** поддержать ленивое переключение контекста для FPU.

# Для души: on-demand paging
Современные ОС не выделяют память сразу после `mmap`, а лишь делают пометку, что процессу выделен регион виртуальной памяти (в Linux это называется VMA = virtual memory area). Первое обращение к странице спровоцирует page fault (потому что такой страницы не существует в таблицах процессора), ОС увидит, что регион выделен через `mmap`, выделит нужную страницу и затем повторит инструкцию. Обычно такой PF называются minor fault'ом.

**Цель:** память при вызове `mmap` не должна выделяться. Вместо этого, страница должна быть выделена при первом обращении к ней.

